;; The first three lines of this file were inserted by DrRacket. They record metadata
;; about the language level of this file in a form that our tools can easily process.
#reader(lib "htdp-beginner-reader.ss" "lang")((modname |2.1 alternative-tuition-graph-solution (mine)-export|) (read-case-sensitive #t) (teachpacks ()) (htdp-settings #(#t constructor repeating-decimal #f #t none #f () #f)))
(require 2htdp/image)

;; alternative-tuition-graph-starter.rkt

; 
; Consider the following alternative type comment for Eva's school tuition 
; information program. Note that this is just a single type, with no reference, 
; but it captures all the same information as the two types solution in the 
; videos.
; 
; (define-struct school (name tuition next))
; ;; School is one of:
; ;;  - false
; ;;  - (make-school String Natural School)
; ;; interp. an arbitrary number of schools, where for each school we have its
; ;;         name and its tuition in USD


; (A) Confirm for yourself that this is a well-formed self-referential data 
;     definition.
; 
; The design recipe for self-referential data informs us that:
; 
; ;In order to be well-formed, a self-referential data definition must:
;     ;(i) have at least one case without self reference (the base case(s))
;     ;(ii) have at least one case with self reference
; 
; The data definition for School does have at least one base case (String) and it
; also has at least one case with self reference (School). This definition is
; therefore well-formed


;; ----------
;; Constants:
;; ----------

;; Same as in class
(define FONT-SIZE 24)
(define FONT-COLOR "black")

(define Y-SCALE   1/200)
(define BAR-WIDTH 30)
(define BAR-COLOR "lightblue")

; (B) Complete the data definition making sure to define all the same examples as 
;     for ListOfSchool in the videos.


;; -----------------
;; Data Definitions:
;; -----------------

(define-struct school (name tuition next))
;; School is one of:
;;  - false
;;  - (make-school String Natural School)
;; interp. an arbitrary number of schools, where for each school we have its
;;         name and its tuition in USD

(define S1 false)

(define S2 (make-school "School1" 27797
                        (make-school "School 2" 23300
                                     (make-school "School 3" 28500 false))))

#;
(define (fn-for-school s)
  (cond [(false? s) (...)]                                ;BASE CASE
        [else (... (school-name s) (school-tuition s)     ;String Natural
                   (fn-for-school (school-next s)))]))    ;School

;; Template rules used:
;;  - one of: 2 cases
;;  - atomic distinct: false
;;  - compound: (make-school String Natural School)
;;  - self-reference: (school-next s) is School

; (C) Design the chart function that consumes School. Save yourself time by 
;     simply copying the tests over from the original version of chart.


;; ----------
;; Functions:
;; ----------

;; School -> Image
;; produce bar chart showing names and tuitions of consumed schools
(check-expect (chart false) (square 0 "solid" "white"))
(check-expect (chart (make-school "S1" 8000 false))
              (beside/align
               "bottom"
               (overlay/align "center" "bottom"
                              (rotate 90 (text "S1" FONT-SIZE FONT-COLOR))
                              (rectangle BAR-WIDTH
                                         (* 8000 Y-SCALE) "outline" "black")
                              (rectangle BAR-WIDTH
                                         (* 8000 Y-SCALE) "solid" BAR-COLOR))
               (square 0 "solid" "white")))

(check-expect (chart (make-school "S2" 12000 (make-school "S1" 8000 false)))
              (beside/align
               "bottom"
               (overlay/align "center" "bottom"
                              (rotate 90 (text "S2" FONT-SIZE FONT-COLOR))
                              (rectangle BAR-WIDTH
                                         (* 12000 Y-SCALE) "outline" "black")
                              (rectangle BAR-WIDTH
                                         (* 12000 Y-SCALE) "solid" BAR-COLOR))
               (overlay/align "center" "bottom"
                              (rotate 90 (text "S1" FONT-SIZE FONT-COLOR))
                              (rectangle BAR-WIDTH
                                         (* 8000 Y-SCALE) "outline" "black")
                              (rectangle BAR-WIDTH
                                         (* 8000 Y-SCALE) "solid" BAR-COLOR))
               (square 0 "solid" "white")))

;(define (chart s) (square 0 "solid" "white"))  ;stub

;<template from School>
(define (chart s)
  (cond [(false? s) (square 0 "solid" "white")]                                
        [else
         (beside/align "bottom"
                       (make-bar (school-name s) (school-tuition s))
                       (chart (school-next s)))]))

;; String Natural -> Image
;; produce the bar for a single school in the bar chart
(check-expect (make-bar "S1" 8000)
              (overlay/align "center" "bottom"
                             (rotate 90 (text "S1" FONT-SIZE FONT-COLOR))
                             (rectangle BAR-WIDTH
                                        (* 8000 Y-SCALE) "outline" "black")
                             (rectangle BAR-WIDTH
                                        (* 8000 Y-SCALE) "solid" BAR-COLOR)))

;(define (make-bar s) (square 0 "solid" "white")) ;stub

(define (make-bar name tuition)
  (overlay/align "center" "bottom"
                 (rotate 90 (text name FONT-SIZE FONT-COLOR))
                 (rectangle BAR-WIDTH
                            (* tuition Y-SCALE) "outline" "black")
                 (rectangle BAR-WIDTH
                            (* tuition Y-SCALE) "solid" BAR-COLOR)))

; (D) Compare the two versions of chart. Which do you prefer? Why?
; 
; Current version:
; ;(define (chart s)
; ;  (cond [(false? s) (square 0 "solid" "white")]                                
; ;        [else
; ;         (beside/align "bottom"
; ;                       (make-bar (school-name s) (school-tuition s))
; ;                       (chart (school-next s)))]))
; 
; Class version:
; ;(define (chart los)
; ;  (cond [(empty? los) (square 0 "solid" "white")]
; ;        [else
; ;         (beside/align "bottom"
; ;                       (make-bar (first los))
; ;                       (chart (rest los)))]))
; 
; The chart functions themselves are quite similar. The only important difference
; is that make-bar is called with two arguments in the former case. This may enhance
; readability of the program as a person can immediately know what will be charted
; just from the one line of code. Because of this, I have a slight preference for the
; current version.
; 
; Note after seeing the official solution: the author(s) state that they prefer the
; class version because it forces the creation of make-bar. In this sense, I agree
; that it is better because it makes you (reminds you to) create a new function -
; however, nothing is stopping the programmer to still separate functionality. In
; fact, we were taught in this same course that it is always good to do this, so in
; this sense the class version only acts as a reminder, and nothing more, to create a
; new function. Hence, we have to create it either way, and then the current version
; still benefits from the enhanced readability.
